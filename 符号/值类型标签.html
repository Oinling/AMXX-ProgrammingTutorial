<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta charset="utf-8">
	<title>AMXXPawn 值类型标签</title>
	<style>
		:root {
			--primary-color: #3498db;
			--secondary-color: #2c3e50;
			--accent-color: #e74c3c;
			--light-bg: #f8f9fa;
			--dark-bg: #eaecef;
			--code-color: #0000ff;
			--border-color: #ddd;
		}

		body {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
			line-height: 1.6;
			color: #333;
			max-width: 900px;
			margin: 0 auto;
			padding: 20px;
			background-color: #f9f9f9;
		}

		h1 {
			color: #2c3e50;
			border-bottom: 2px solid #3498db;
			padding-bottom: 10px;
			text-align: center;
		}

		h2,
		h3 {
			color: #2c3e50;
			border-bottom: 1px solid #eee;
			padding-bottom: 10px;
		}

		p {
			margin: 15px 0;
		}

		code {
			display: block;
			white-space: pre;
			background-color: #f5f5f5;
			border: 1px solid #ddd;
			border-radius: 4px;
			color: #0000ff;
			padding: 15px;
			overflow-x: auto;
			font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
			line-height: 1.5;
			margin: 15px 0;
			box-shadow: 0 1px 3px #0000001a;
		}

		.amxx-default {
			color: #0000ff;
		}

		.amxx-note {
			color: #000000;
		}

		.amxx-comment {
			color: #3f9f3f;
		}

		.amxx-di {
			color: #6f6f6b;
		}

		.amxx-df {
			background: linear-gradient(to right, #6f6f6b, #711fc3);
			background-clip: text;
			-webkit-background-clip: text;
			color: transparent;
			font-weight: bold;
		}

		.amxx-string {
			color: #c0392b;
		}

		.amxx-number {
			color: #000000;
			font-weight: bold;
		}

		.amxx-enumname {
			background: linear-gradient(to right, #5d140a, #9933ff);
			background-clip: text;
			-webkit-background-clip: text;
			color: transparent;
		}

		.amxx-of {
			background: linear-gradient(to right, #0000ff, #711fc3);
			background-clip: text;
			-webkit-background-clip: text;
			color: transparent;
			font-weight: bold;
		}

		.amxx-function {
			color: #711fc3;
			font-weight: bold;
		}

		.amxx-tag {
			color: #5d140a;
		}

		.amxx-identifier {
			color: #9933ff;
			font-weight: bold;
		}

		.highlight {
			background-color: #fffde7;
			padding: 2px 4px;
			border-radius: 3px;
		}

		.note-box {
			background-color: #e3f2fd;
			border-left: 4px solid #2196f3;
			padding: 15px;
			margin: 20px 0;
			border-radius: 0 4px 4px 0;
		}

		.warning-box {
			background-color: #ffebee;
			border-left: 4px solid #f44336;
			padding: 15px;
			margin: 20px 0;
			border-radius: 0 4px 4px 0;
		}

		.feature-list {
			background-color: #e8f5e9;
			border-left: 4px solid #4caf50;
			padding: 15px;
			margin: 20px 0;
			border-radius: 0 4px 4px 0;
		}

		.codetable {
			width: 100%;
			border-collapse: collapse;
			margin: 20px 0;
			box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
		}

		.codetable th,
		.codetable td {
			border: 1px solid var(--border-color);
			padding: 12px 15px;
			text-align: left;
		}

		.codetable th {
			background-color: var(--secondary-color);
			color: white;
			font-weight: bold;
		}

		.codetable tr:nth-child(even) {
			background-color: var(--light-bg);
		}

		.codetable tr:hover {
			background-color: var(--dark-bg);
		}
	</style>
</head>

<body>
	<h1>AMXXPawn 值类型标签</h1>

	<h2>1. 简介</h2>
	<p>值类型标签（Tag）能在编译时为表达式提供类型检查，或匹配运算符重载，进行文本替换。</p>
	<p>标签对开发者而言能增强语义区分，帮助开发者更安全地编写代码。</p>
	<p>不同标签的表达式做运算，通常会触发警告，除非与某个运算符重载匹配，或其一拥有any标签。</p>
	<p>标签拥有uid，可通过<a href="https://oinling.github.io/AMXX-ProgrammingTutorial/%E4%BF%9D%E7%95%99%E8%AF%8D/tagof.html">tagof</a>关键字获取。</p>
	<p>编译前AMX Mod X会自动生成3个默认标签：</p>
	<table class="codetable">
	<tr>
		<th>名称</th>
		<th>作用</th>
	</tr>
	<tr>
		<td>any</td>
		<td>拥有此标签的表达式参与运算时，编译器不会进行类型检查</td>
	</tr>
	<tr>
		<td>bool</td>
		<td>拥有此标签的表达式若等于0，表示否定，若等于其他数值，表示肯定</td>
	</tr>
	<tr>
		<td>_</td>
		<td>所有表达式的默认标签，说明表达式的值是整数</td>
	</tr>
	</table>
	<p>除了默认标签，其它标签是在编译时生成的，因此每个插件生成的同名标签uid不一定相同，并且编译后标签会被删除。</p>
	<div class="warning-box">
		<h4>注意：</h4>
		<h4>不同版本AMX Mod X的默认标签也不拥有相同的uid，不要依靠uid辨别其它插件传递的数据类型，不可靠。</h4>
		<h4><span class="highlight">Float</span>并不是默认标签，需使用<span class="highlight">#pragma rational</span>指令创建，或引用float.inc文件，才能使用。</h4>
		<h4>float.inc已被amxmodx.inc文件引用，所以引用amxmodx.inc也是可以的。</h4>
		<h4>使用<span class="highlight">#pragma rational</span>指令创建浮点数标签之前，编译器不会允许用户使用浮点数字面量。</h4>
	</div>
	
	<h2>2. 声明标识符时设定标签</h2>
	<p>用户在声明标识符时，若不设置标签，则默认标识符拥有_标签。</p>
	<p>用户在声明标识符时，若设置不存在的标签，编译器会自动创建该标签。因此，引用inc文件后会获得很多标签。</p>

	<div class="note-box">

	<h4>常量标签：</h4>
	<ul>
		<li>用户在设定常量值时，需填写拥有相同标签的表达式</li>
		<li>常量被用于运算时，通常要求其它操作数拥有相同标签</li>
		<li><a href="https://oinling.github.io/AMXX-ProgrammingTutorial/%E7%AC%A6%E5%8F%B7/%E5%B8%B8%E9%87%8F.html">点击查看常量指南</a></li>
	</ul>

	<h4>结构体属性标签：</h4>
	<ul>
		<li>声明枚举常量时可以设置结构体属性标签，默认为_标签</li>
		<li>用户用枚举常量当做索引获取数组元素时，通常要求其它操作数拥有相同标签</li>
		<li><a href="https://oinling.github.io/AMXX-ProgrammingTutorial/%E4%BF%9D%E7%95%99%E8%AF%8D/enum.html">点击查看枚举指南</a></li>
	</ul>

	<h4>变量标签：</h4>
	<ul>
		<li>用户在赋值或设定默认值时，需填写拥有相同标签的表达式</li>
		<li>变量被用于运算时，通常要求其它操作数拥有相同标签</li>
		<li><a href="https://oinling.github.io/AMXX-ProgrammingTutorial/%E7%AC%A6%E5%8F%B7/%E5%8F%98%E9%87%8F.html#Tag">点击变量指南</a></li>
	</ul>

	<h4>数组索引器标签：</h4>
	<ul>
		<li>用户在为数组赋值时，需填写索引器拥有相同标签的数组</li>
		<li>用户在填写索引访问数组元素时，索引标签需与索引器相同</li>
		<li>索引器默认使用_标签，若填写小写开头的枚举类名，编译器会灵活切换索引器和索引标签</li>
		<li><a href="https://oinling.github.io/AMXX-ProgrammingTutorial/%E4%BF%9D%E7%95%99%E8%AF%8D/enum.html">点击查看枚举指南</a></li>
	</ul>

	<h4>函数标签：</h4>
	<ul>
		<li>用户在设置返回值时，需填写拥有相同标签的表达式</li>
		<li>函数被用于运算时，通常要求其它操作数拥有相同标签</li>
		<li><a href="https://oinling.github.io/AMXX-ProgrammingTutorial/%E7%AC%A6%E5%8F%B7/%E5%87%BD%E6%95%B0.html">点击查看函数指南</a></li>
	</ul>

	<h4>函数索引器标签：</h4>
	<ul>
		<li>函数返回值被复制给数组时，要求数组索引器拥有相同标签</li>
		<li>注意：仅native函数允许拥有索引器，提醒第三方用户使用方法。其余函数返回值是用户自设，无需索引器</li>
	</ul>
	</div>

	<h2>3. 标签覆盖</h2>
	<p>在任意表达式左边，可以使用标签覆盖表达式，临时更改表达式的标签。</p>
	<p><strong>重点1：</strong>标签无实际意义，会在编译时被删除。标签覆盖<span class="highlight">不会改变表达式的数值</span>。</p>
	<p><strong>重点2：</strong>复合表达式的操作数无论带有什么标签，默认情况下<span class="highlight">只会进行整数之间的运算</span>。但两操作数的标签不同可能触发警告。</p>
	<p><strong>重点3：</strong>amxx插件与AMX Mod X通过native或forward函数交换数据，数据（表达式）的标签<span class="highlight">不影响函数计算结果</span>。</p>
	<p><strong>重点4：</strong><a href="https://oinling.github.io/AMXX-ProgrammingTutorial/%E4%BF%9D%E7%95%99%E8%AF%8D/operator.html">operator</a>关键字可定义文本替换规则（运算符重载），<span class="highlight">将满足规则的复合表达式替换为函数与参数</span>。</p>
	<p><strong>重点5：</strong>覆盖标签可以主动满足或避开运算符重载定义的文本替换规则，或屏蔽某些标签不匹配的警告。</p>
	<p><strong>重点6：</strong>一旦满足运算符重载的文本替换规则，替换成函数运算后，<span class="highlight">计算结果可能与预期不符</span>。</p>

	<div class="note-box">
	<h4>整数字面量默认带有_标签，若使用带有Float标签的常量或变量储存，将触发警告。</h4>
	<h4>此时可对字面量使用标签覆盖，屏蔽这个赋值表达式的“标签不匹配”警告：</h4>
	<code><span class="amxx-comment">// 若不覆盖标签，因常量和常量值标签不同，将触发警告：“标签不匹配”</span>
const <span class="amxx-tag">Float:</span><span class="amxx-identifier">FLOAT_NEGATIVE_INFINITY</span> = <span class="amxx-number">0b_01000000_01001001_00000000_00000000</span>;
<span class="amxx-comment">// 浮点型常量：负无穷</span>
const <span class="amxx-tag">Float:</span><span class="amxx-identifier">FLOAT_NEGATIVE_INFINITY</span> = <span class="highlight"><span class="amxx-tag">Float:</span></span><span class="amxx-number">0b_01000000_01001001_00000000_00000000</span>;</code>
	</div>

<div class="note-box">
<h4>我们接收到某些数据时，可能会遇到其标签不符合我们的语义需求，此时需使用标签覆盖。</h4>
<code><span class="amxx-comment">// 此函数返回值是1和0，表示肯定和否定。</span>
native <span class="amxx-function">is_user_alive</span>(<span class="amxx-identifier">index</span>);
public <span class="amxx-function">PlayerPreThink_Post</span>(<span class="amxx-identifier">playerEntId</span>)
{
	<span class="amxx-comment">// 我们通常使用带有bool标签的标识符表示肯定与否定，若直接储存1或0将在编译时被警告“标签不匹配”</span>
	<span class="amxx-comment">// 因此，临时更改is_user_alive函数的标签，屏蔽警告（看函数的源码或注释，确认其绝对只会返回1或0）</span>
	new const <span class="amxx-tag">bool:</span><span class="amxx-identifier">isAlive</span> = <span class="highlight"><span class="amxx-tag">bool:</span></span><span class="amxx-function">is_user_alive</span>(<span class="amxx-identifier">playerEntId</span>);
}</code>

<code><span class="amxx-comment">// 假如我们制作了一个默认风格的native函数，接受队伍索引作为参数，返回值是敌方队伍的索引</span>
native <span class="amxx-function">GetEnemyTeam</span>(<span class="amxx-tag">CsTeams:</span><span class="amxx-identifier">team</span>);
public <span class="amxx-tag">CsTeams:</span><span class="amxx-function">@GetEnemyTeam</span>()
{
	<span class="amxx-comment">// amxmodx.inc提供的get_param和get_param_f函数可根据号数获取非数组类型的传值参数值</span>
	<span class="amxx-comment">// 它们返回值分别带有_和Float标签，而我们需要的是带有CsTeams标签的参数值</span>
	<span class="amxx-comment">// 已知：标签无意义，在编译时被删除，标签不会改变数据，函数运行时不能得知参数原本的标签</span>
	<span class="amxx-comment">// 因此我们直接使用其中任意一个函数，将其标签覆盖为CsTeams</span>
	new <span class="amxx-tag">CsTeams:</span><span class="amxx-identifier">team</span> = <span class="highlight"><span class="amxx-tag">CsTeams:</span></span><span class="amxx-function">get_param</span>(<span class="amxx-number">1</span>);

	<span class="amxx-comment">// 由于我们无法确定参数值原本的数据类型，自然也无法保证其真的是队伍索引</span>
	<span class="amxx-comment">// 因此，我们需要判断其是否在正确范围内（CS_TEAM_UNASSIGNED~CS_TEAM_SPECTATOR）</span>
	<span class="amxx-comment">// 或者直接判断是否等于CS_TEAM_T（匪徒）或CS_TEAM_CT（警察）</span>
	<span class="amxx-comment">// 或者使用switch编写各种判断分支</span>
	switch (<span class="amxx-identifier">team</span>)
	{
		<span class="amxx-comment">// 若参数值等于匪徒队伍索引，返回警察队伍索引</span>
		case <span class="amxx-identifier">CS_TEAM_T</span>:	return <span class="amxx-identifier">CS_TEAM_CT</span>;
		<span class="amxx-comment">// 若参数值等于警察队伍索引，返回匪徒队伍索引</span>
		case <span class="amxx-identifier">CS_TEAM_CT</span>:return <span class="amxx-identifier">CS_TEAM_T</span>;
	}
	<span class="amxx-comment">// 若参数值等于未分配队伍索引、观察者队伍索引、或非法数据，统一返回未分配队伍索引</span>
	return <span class="amxx-identifier">CS_TEAM_UNASSIGNED</span>;
}</code>
</div>

	<div class="note-box">
	<h4>某些模块提供了储存、获取数据的功能，假如我们储存的是浮点数的数据，但获取数据的函数不带有Float的标签。</h4>
	<h4>若该函数带有any标签，可直接用浮点型变量储存其返回值。</h4>
	<h4>但若想直接将其返回值用于参与浮点数运算，只要其标签不是Float，必须使用标签覆盖，使其正确匹配运算符重载。</h4>
	<code><span class="amxx-di">#include</span> <<span class="amxx-string">amxmodx</span>>
<span class="amxx-di">#include</span> <<span class="amxx-string">cellarray</span>>	<span class="amxx-comment">// 引用Array系列native函数声明。可省略，amxmodx.inc已经引用这个文件了</span>
<span class="amxx-di">#include</span> <<span class="amxx-string">float</span>>	<span class="amxx-comment">// 引用浮点数相关运算符重载。可省略，amxmodx.inc已经引用这个文件了</span>

public <span class="amxx-function">plugin_precache</span>()
{
	<span class="amxx-comment">// 创建动态数组，将一个浮点数数据存入数组内</span>
	new <span class="amxx-enumname">Array:</span><span class="amxx-identifier">handle</span> = <span class="amxx-function">ArrayCreate</span>();
	<span class="amxx-function">ArrayPushCell</span>(<span class="amxx-identifier">handle</span>, <span class="amxx-number">5.0</span>);

	<span class="amxx-comment">// 假如我们想直接判断数组内的数据是否等于5.0（执行两个浮点数之间的相等比较）
	// 必须对ArrayGetCell函数使用标签覆盖，确保其满足Float: == Float:这个运算符重载的文本替换规则
	// 这种情况下，括号内容会被替换为floatcmp(5.0, ArrayGetCell(handle, 0)) == 0并且计算结果为1，满足if条件
	// 若不覆盖标签，将会满足Float: == any:的文本替换规则（实际没有这条规则，所以是Float: == _:）
	// 这种情况下，括号内容会被替换为floatcmp(5.0, float(ArrayGetCell(handle, 0))) == 0并且计算结果为0，不满足if条件
	// 因为数组内的浮点数数据5.0实际等于整数1084227584，会被float函数转换为1084227584.0
	// 而5.0与1084227584.0不相等，不满足if条件</span>
	if (<span class="amxx-number">5.0</span> == <span class="amxx-enumname">Float:</span><span class="amxx-function">ArrayGetCell</span>(<span class="amxx-identifier">handle</span>, <span class="amxx-number">0</span>))
	{
		<span class="amxx-function">server_print</span>(<span class="amxx-string">"数组内的第一个元素等于浮点数5.0或整数1084227584"</span>);
	}
}</code>
	</div>

	<div class="note-box">
<h4>运算符重载代码示例：</h4>

<code><span class="amxx-comment">// 将两个浮点数的二进制整数发给核心模块，执行浮点数加法，得到结果后返回二进制整数</span>
native <span class="amxx-tag">Float:</span><span class="amxx-function">floatadd</span>(<span class="amxx-tag">Float:</span><span class="amxx-identifier">oper1</span>, <span class="amxx-tag">Float:</span><span class="amxx-identifier">oper2</span>);

<span class="amxx-comment">// 若源码中存在两个带有Float标签的表达式相加，例如1.0 + 2.0，编译后将其替换成floatadd(1.0, 2.0)</span>
native <span class="amxx-tag">Float:</span><span class="amxx-of">operator+</span>(<span class="amxx-tag">Float:</span><span class="amxx-identifier">oper1</span>, <span class="amxx-tag">Float:</span><span class="amxx-identifier">oper2</span>) = <span class="amxx-function">floatadd</span>;

<span class="amxx-comment">// 若源码中带有Float标签的变量使用了++自增，例如++v，将其替换为v = floatadd(v, 1.0)</span>
stock <span class="amxx-tag">Float:</span><span class="amxx-of">operator++</span>(<span class="amxx-tag">Float:</span><span class="amxx-identifier">oper</span>)
	return <span class="amxx-identifier">oper</span>+<span class="amxx-number">1.0</span>;</code>
</div>

	<p>AMX Mod X的float.inc文件提供了Float与Float数据、Float与_数据、_与Float数据做运算的文本替换规则。</p>

	<p>因此，当我们引用了float.inc或amxmodx.inc（它引用了float.inc)文件，须注意是否对复合表达式的操作数进行标签覆盖。</p>

	<p>特别是其中一个操作数拥有Float标签而另一个没有的情况。</p>

</body>

</html>